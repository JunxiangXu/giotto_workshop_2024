[["index.html", "Workshop: Spatial multi-omics data analysis with Giotto Suite 1 Giotto Workshop 2024 1.1 Instructors 1.2 Topics and Schedule: 1.3 License", " Workshop: Spatial multi-omics data analysis with Giotto Suite Ruben Dries, Jiaji George Chen, Joselyn Cristina Chávez-Fuentes, Junxiang Xu , Edward Ruiz, Jeff Sheridan, Wen Wang 1 Giotto Workshop 2024 Workshop: Spatial multi-omics data analysis with Giotto Suite 1.1 Instructors Ruben Dries: Assistant Professor of Medicine at Boston University Joselyn Cristina Chávez Fuentes: Postdoctoral fellow at Icahn School of Medicine at Mount Sinai Jiaji George Chen: Ph.D. Student at Boston University Junxiang Xu Edward C. Ruiz: Ph.D. Student at Boston University Jeff Sheridan Wen Wang 1.2 Topics and Schedule: Day 1: Introduction Spatial omics technologies Spatial sequencing Spatial in situ Spatial proteomics spatial other: ATAC-seq, lipidomics, etc Introduction to the Giotto package Ecosystem Installation + python environment Giotto instructions Data formatting and Pre-processing Creating a Giotto object From matrix + locations From subcellular raw data (transcripts or images) + polygons Using convenience functions for popular technologies (Vizgen, Xenium, CosMx, …) Spatial plots Subsetting: Based on IDs Based on locations Visualizations Introduction to spatial multi-modal dataset (10X Genomics breast cancer) and goal for the next days Quality control Statistics Normalization Feature selection: Highly Variable Features: loess regression binned pearson residuals Spatial variable genes Dimension Reduction PCA UMAP/t-SNE Visualizations Clustering Non-spatial k-means Hierarchical clustering Leiden/Louvain Spatial Spatial variable genes Spatial co-expression modules Day 2: Spatial Data Analysis Spatial sequencing based technology: Visium Differential expression Enrichment &amp; Deconvolution PAGE/Rank SpatialDWLS Visualizations Interactive tools Spatial expression patterns Spatial variable genes Spatial co-expression modules Spatial HMRF Spatial sequencing based technology: Visium HD Tiling and aggregation Scalability (duckdb) and projection functions Spatial expression patterns Spatial co-expression module Spatial in situ technology: Xenium Read in raw data Transcript coordinates Polygon coordinates Visualizations Overlap txs &amp; polygons Typical aggregated workflow Feature/molecule specific analysis Visualizations Transcript enrichment GSEA Spatial location analysis Spatial cell type co-localization analysis Spatial niche analysis Spatial niche trajectory analysis Visualizations Spatial proteomics: multiplex IF Read in raw data Intensity data (IF or any other image) Polygon coordinates Visualizations Overlap intensity &amp; workflows Typical aggregated workflow Visualizations Day 3: Advanced Tutorials Multiple samples Create individual giotto objects Join Giotto Objects Perform Harmony and default workflows Visualizations Spatial multi-modal Co-registration of datasets Examples in giotto suite manuscript Multi-omics integration Example in giotto suite manuscript Interoperability w/ other frameworks AnnData/SpatialData SpatialExperiment Seurat Interoperability w/ isolated tools Spatial niche trajectory analysis Interactivity with the R/Spatial ecosystem Kriging Contributing to Giotto 1.3 License This material has a Creative Commons Attribution-ShareAlike 4.0 International License. To get more information about this license, visit http://creativecommons.org/licenses/by-sa/4.0/ "],["spatial-omics-technologies.html", "2 Spatial omics technologies 2.1 Slides 2.2 Spatial sequencing", " 2 Spatial omics technologies Ruben Dries August 5th 2024 2.1 Slides 2.2 Spatial sequencing Spatial in situ Spatial proteomics spatial other: ATAC-seq, lipidomics, etc "],["introduction-to-the-giotto-package.html", "3 Introduction to the Giotto package 3.1 Slides 3.2 Ecosystem 3.3 Installation + python environment 3.4 Giotto instructions", " 3 Introduction to the Giotto package Ruben Dries August 5th 2024 3.1 Slides 3.2 Ecosystem 3.3 Installation + python environment 3.4 Giotto instructions "],["data-formatting-and-pre-processing.html", "4 Data formatting and Pre-processing 4.1 Data formats 4.2 Pre-processing", " 4 Data formatting and Pre-processing Jiaji George Chen August 5th 2024 save_dir &lt;- &quot;~/Documents/GitHub/giotto_workshop_2024/img/01_session3&quot; 4.1 Data formats .h5 .mtx - get10xmatrix .parquet .csv/.tsv - fread .json -jsonlite .geojson .tiff/.ome.tif 4.2 Pre-processing necessary additional packages? "],["creating-a-giotto-object.html", "5 Creating a Giotto object 5.1 From matrix + locations 5.2 From subcellular raw data (transcripts or images) + polygons 5.3 From piece-wise 5.4 Using convenience functions for popular technologies (Vizgen, Xenium, CosMx, …) 5.5 Spatial plots 5.6 Subsetting 5.7 Mini objects &amp; GiottoData", " 5 Creating a Giotto object Jiaji George Chen August 5th 2024 save_dir &lt;- &quot;~/Documents/GitHub/giotto_workshop_2024/img/01_session4&quot; 5.1 From matrix + locations createGiottoObject() 5.2 From subcellular raw data (transcripts or images) + polygons createGiottoObjectSubcellular() 5.3 From piece-wise g &lt;- giotto() g &lt;- setGiotto(g, ??) 5.4 Using convenience functions for popular technologies (Vizgen, Xenium, CosMx, …) createGiottoVisiumObject() createGiottoXeniumObject() createGiottoCosMxObject() createGiottoMerscopeObject() 5.5 Spatial plots some text 5.6 Subsetting Based on IDs Based on locations Visualizations 5.7 Mini objects &amp; GiottoData Giotto makes available several mini objects to allow devs and users to work with easily loadable Giotto objects. These are small subsets of a larger dataset that often contain some worked through analyses and are fully functional. pak::pak(&quot;drieslab/GiottoData&quot;) "],["visium-part-i.html", "6 Visium Part I 6.1 Introduction to spatial dataset 6.2 Create the Giotto object 6.3 Subset on spots that were covered by tissue 6.4 Quality control 6.5 Filtering 6.6 Normalization 6.7 Feature selection 6.8 Dimension Reduction 6.9 Clustering 6.10 Save the object", " 6 Visium Part I Joselyn Cristina Chávez Fuentes August 5th 2024 6.1 Introduction to spatial dataset 10X genomics recently launched a new platform to obtain spatial expression data using a Visium Spatial Gene Expression slide. The Visium brain data to run this tutorial can be found here You need to download the expression matrix and spatial information by running these commands: dir.create(&quot;data&quot;) download.file(url = &quot;https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Adult_Mouse_Brain/V1_Adult_Mouse_Brain_raw_feature_bc_matrix.tar.gz&quot;, destfile = &quot;data/V1_Adult_Mouse_Brain_raw_feature_bc_matrix.tar.gz&quot;) download.file(url = &quot;https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Adult_Mouse_Brain/V1_Adult_Mouse_Brain_spatial.tar.gz&quot;, destfile = &quot;data/V1_Adult_Mouse_Brain_spatial.tar.gz&quot;) After downloading, unzip the gz files. You should get the “raw_feature_bc_matrix” and “spatial” folders inside “data/”. 6.2 Create the Giotto object library(Giotto) ## Set instructions results_folder &lt;- &quot;results/&quot; python_path &lt;- NULL instructions &lt;- createGiottoInstructions( save_dir = results_folder, save_plot = TRUE, show_plot = FALSE, python_path = python_path ) ## Provide the path to the visium folder data_path &lt;- &quot;data&quot; ## Create object directly from visium folder visium_brain &lt;- createGiottoVisiumObject( visium_dir = data_path, expr_data = &quot;raw&quot;, png_name = &quot;tissue_lowres_image.png&quot;, gene_column_index = 2, instructions = instructions ) 6.3 Subset on spots that were covered by tissue ## show plot spatPlot2D( gobject = visium_brain, cell_color = &quot;in_tissue&quot;, point_size = 2, cell_color_code = c(&quot;0&quot; = &quot;lightgrey&quot;, &quot;1&quot; = &quot;blue&quot;), show_image = TRUE, image_name = &quot;image&quot; ) metadata &lt;- pDataDT(gobject = visium_brain) in_tissue_barcodes &lt;- metadata[in_tissue == 1]$cell_ID visium_brain &lt;- subsetGiotto(gobject = visium_brain, cell_ids = in_tissue_barcodes) 6.4 Quality control Statistics visium_brain_statistics &lt;- addStatistics(gobject = visium_brain, expression_values = &quot;raw&quot;) ## visualize spatPlot2D(gobject = visium_brain_statistics, cell_color = &quot;nr_feats&quot;, color_as_factor = FALSE) filterDistributions(gobject = visium_brain_statistics, detection = &quot;cells&quot;) filterDistributions(gobject = visium_brain_statistics, detection = &quot;feats&quot;) filterCombinations() may be used to test how different filtering parameters will affect the number of cells and features in the filtered data: filterCombinations(gobject = visium_brain_statistics, expression_thresholds = c(1, 2, 3), feat_det_in_min_cells = c(50, 100, 200), min_det_feats_per_cell = c(500, 1000, 1500)) 6.5 Filtering visium_brain &lt;- filterGiotto( gobject = visium_brain, expression_threshold = 1, feat_det_in_min_cells = 50, min_det_feats_per_cell = 1000, expression_values = &quot;raw&quot;, verbose = TRUE ) Feature type: rna Number of cells removed: 4 out of 2702 Number of feats removed: 7311 out of 22125 6.6 Normalization visium_brain &lt;- normalizeGiotto( gobject = visium_brain, scalefactor = 6000, verbose = TRUE ) visium_brain &lt;- addStatistics(gobject = visium_brain) ## visualize spatPlot2D(gobject = visium_brain, cell_color = &quot;nr_feats&quot;, color_as_factor = FALSE) 6.7 Feature selection 6.7.1 Highly Variable Features: loess regression visium_brain &lt;- calculateHVF(gobject = visium_brain, method = &quot;cov_loess&quot;, save_plot = TRUE, default_save_name = &quot;HVFplot_loess&quot;) pearson residuals visium_brain &lt;- calculateHVF(gobject = visium_brain, method = &quot;var_p_resid&quot;, save_plot = TRUE, default_save_name = &quot;HVFplot_pearson&quot;) binned visium_brain &lt;- calculateHVF(gobject = visium_brain, method = &quot;cov_groups&quot;, save_plot = TRUE, default_save_name = &quot;HVFplot_binned&quot;) 6.8 Dimension Reduction 6.8.1 PCA Default visium_brain &lt;- runPCA(gobject = visium_brain) Using specific features my_features &lt;- head(getFeatureMetadata(visium_brain, output = &quot;data.table&quot;)$feat_ID, 1000) visium_brain &lt;- runPCA(gobject = visium_brain, feats_to_use = my_features, name = &quot;custom_pca&quot;) Visualization Screeplot screePlot(gobject = visium_brain, ncp = 30) PCA plotPCA(gobject = visium_brain) Custom PCA plotPCA(gobject = visium_brain, dim_reduction_name = &quot;custom_pca&quot;) 6.8.2 UMAP visium_brain &lt;- runUMAP(visium_brain, dimensions_to_use = 1:10) Visualization plotUMAP(gobject = visium_brain) 6.8.3 t-SNE visium_brain &lt;- runtSNE(gobject = visium_brain, dimensions_to_use = 1:10) Visualization plotTSNE(gobject = visium_brain) 6.9 Clustering Create a sNN network (default) visium_brain &lt;- createNearestNetwork(gobject = visium_brain, dimensions_to_use = 1:10, k = 15) Create a kNN network visium_brain &lt;- createNearestNetwork(gobject = visium_brain, dimensions_to_use = 1:10, k = 15, type = &quot;kNN&quot;) 6.9.1 Calculate Leiden clustering visium_brain &lt;- doLeidenCluster(gobject = visium_brain, resolution = 0.4, n_iterations = 1000) Visualization plotPCA(gobject = visium_brain, cell_color = &quot;leiden_clus&quot;) plotUMAP(gobject = visium_brain, cell_color = &quot;leiden_clus&quot;, show_NN_network = FALSE, point_size = 2.5) plotUMAP(gobject = visium_brain, cell_color = &quot;leiden_clus&quot;, show_NN_network = TRUE, point_size = 2.5) plotTSNE(gobject = visium_brain, cell_color = &quot;leiden_clus&quot;, point_size = 2.5) plotTSNE(gobject = visium_brain, cell_color = &quot;leiden_clus&quot;, point_size = 2.5, show_NN_network = TRUE) Dimension plots grouped by cluster spatPlot2D(visium_brain, cell_color = &quot;leiden_clus&quot;) 6.9.2 Calculate Louvain clustering visium_brain &lt;- doLouvainCluster(visium_brain) spatPlot2D(visium_brain, cell_color = &quot;louvain_clus&quot;) 6.10 Save the object saveGiotto(visium_brain, &quot;visium_brain_object&quot;) "],["visium-part-ii.html", "7 Visium Part II 7.1 Load the object 7.2 Differential expression 7.3 Enrichment &amp; Deconvolution 7.4 Spatial expression patterns 7.5 Interactive tools", " 7 Visium Part II Joselyn Cristina Chávez Fuentes August 6th 2024 7.1 Load the object library(Giotto) visium_brain &lt;- loadGiotto(&quot;visium_brain_object&quot;) 7.2 Differential expression 7.2.1 Gini markers Calculate the top marker genes per cluster using the gini method gini_markers &lt;- findMarkers_one_vs_all(gobject = visium_brain, method = &quot;gini&quot;, expression_values = &quot;normalized&quot;, cluster_column = &quot;leiden_clus&quot;, min_feats = 10) topgenes_gini &lt;- gini_markers[, head(.SD, 2), by = &quot;cluster&quot;]$feats Visualize violinPlot(visium_brain, feats = unique(topgenes_gini), cluster_column = &quot;leiden_clus&quot;, strip_text = 6, strip_position = &quot;right&quot;, save_param = list(base_width = 5, base_height = 30)) plotMetaDataHeatmap(visium_brain, selected_feats = unique(topgenes_gini), metadata_cols = &quot;leiden_clus&quot;, x_text_size = 10, y_text_size = 10) dimFeatPlot2D(visium_brain, expression_values = &quot;scaled&quot;, feats = sort(unique(topgenes_gini)), cow_n_col = 5, point_size = 1, save_param = list(base_width = 15, base_height = 20)) 7.2.2 Scran markers Calculate the top marker genes per cluster using the scran method scran_markers &lt;- findMarkers_one_vs_all(gobject = visium_brain, method = &quot;scran&quot;, expression_values = &quot;normalized&quot;, cluster_column = &quot;leiden_clus&quot;, min_feats = 10) topgenes_scran &lt;- scran_markers[, head(.SD, 2), by = &quot;cluster&quot;]$feats Visualize violinPlot(visium_brain, feats = unique(topgenes_scran), cluster_column = &quot;leiden_clus&quot;, strip_text = 6, strip_position = &quot;right&quot;, save_param = list(base_width = 5, base_height = 30)) plotMetaDataHeatmap(visium_brain, selected_feats = unique(topgenes_scran), metadata_cols = &quot;leiden_clus&quot;, x_text_size = 10, y_text_size = 10) dimFeatPlot2D(visium_brain, expression_values = &quot;scaled&quot;, feats = sort(unique(topgenes_scran)), cow_n_col = 5, point_size = 1, save_param = list(base_width = 20, base_height = 20)) 7.3 Enrichment &amp; Deconvolution Visium spatial transcriptomics does not provide single-cell resolution, making cell type annotation a harder problem. Giotto provides several ways to calculate enrichment of specific cell-type signature gene lists. Download the single-cell dataset GiottoData::getSpatialDataset(dataset = &quot;scRNA_mouse_brain&quot;, directory = &quot;data/&quot;) Create the single-cell object results_folder &lt;- &quot;results/&quot; python_path &lt;- NULL instructions &lt;- createGiottoInstructions( save_dir = results_folder, save_plot = TRUE, show_plot = FALSE, python_path = python_path ) sc_expression &lt;- &quot;data/brain_sc_expression_matrix.txt.gz&quot; sc_metadata &lt;- &quot;data/brain_sc_metadata.csv&quot; giotto_SC &lt;- createGiottoObject(expression = sc_expression, instructions = instructions) giotto_SC &lt;- addCellMetadata(giotto_SC, new_metadata = data.table::fread(sc_metadata)) giotto_SC &lt;- normalizeGiotto(giotto_SC) 7.3.1 PAGE/Rank Calculate the cell type markers markers_scran &lt;- findMarkers_one_vs_all(gobject = giotto_SC, method = &quot;scran&quot;, expression_values = &quot;normalized&quot;, cluster_column = &quot;Class&quot;, min_feats = 3) top_markers &lt;- markers_scran[, head(.SD, 10), by = &quot;cluster&quot;] celltypes &lt;- levels(factor(markers_scran$cluster)) Create the signature matrix sign_list &lt;- list() for (i in 1:length(celltypes)){ sign_list[[i]] = top_markers[which(top_markers$cluster == celltypes[i]),]$feats } sign_matrix &lt;- makeSignMatrixPAGE(sign_names = celltypes, sign_list = sign_list) Run the enrichment test with PAGE visium_brain &lt;- runPAGEEnrich(gobject = visium_brain, sign_matrix = sign_matrix) Visualize cell_types_PAGE &lt;- colnames(sign_matrix) plotMetaDataCellsHeatmap(gobject = visium_brain, metadata_cols = &quot;leiden_clus&quot;, value_cols = cell_types_PAGE, spat_enr_names = &quot;PAGE&quot;, x_text_size = 8, y_text_size = 8) spatCellPlot2D(gobject = visium_brain, spat_enr_names = &quot;PAGE&quot;, cell_annotation_values = cell_types_PAGE, cow_n_col = 3, coord_fix_ratio = 1, point_size = 1, show_legend = TRUE) 7.3.2 SpatialDWLS Create the signature matrix sign_matrix &lt;- makeSignMatrixDWLSfromMatrix(matrix = getExpression(giotto_SC, values = &quot;normalized&quot;, output = &quot;matrix&quot;), cell_type = pDataDT(giotto_SC)$Class, sign_gene = top_markers$feats) Run the DWLS Deconvolution visium_brain &lt;- runDWLSDeconv(gobject = visium_brain, sign_matrix = sign_matrix) Visualize # Plot DWLS deconvolution result with Pie plots spatDeconvPlot(visium_brain, show_image = FALSE, radius = 50, save_param = list(save_name = &quot;08_spat_DWLS_pie_plot&quot;)) 7.4 Spatial expression patterns 7.4.1 Spatial variable genes Rank binarization ranktest = binSpect(visium_brain, bin_method = &quot;rank&quot;, calc_hub = TRUE, hub_min_int = 5, spatial_network_name = &quot;spatial_network&quot;) Visualize spatFeatPlot2D(visium_brain, expression_values = &quot;scaled&quot;, feats = ranktest$feats[1:6], cow_n_col = 2, point_size = 1.5) 7.4.2 Spatial co-expression modules Cluster the top 500 spatial genes into 20 clusters ext_spatial_genes = ranktest[1:1500,]$feats Use existing detectSpatialCorGenes function to calculate pairwise distances between genes (but set network_smoothing=0 to use default clustering) spat_cor_netw_DT = detectSpatialCorFeats(visium_brain, method = &quot;network&quot;, spatial_network_name = &quot;spatial_network&quot;, subset_feats = ext_spatial_genes) Identify most similar spatially correlated genes for one gene top10_genes = showSpatialCorFeats(spat_cor_netw_DT, feats = &quot;Ptprn&quot;, show_top_feats = 10) Visualize spatFeatPlot2D(visium_brain, expression_values = &quot;scaled&quot;, feats = top10_genes$variable[1:4], point_size = 3) Cluster spatial genes spat_cor_netw_DT = clusterSpatialCorFeats(spat_cor_netw_DT, name = &quot;spat_netw_clus&quot;, k = 20) Visualize clusters heatmSpatialCorFeats(visium_brain, spatCorObject = spat_cor_netw_DT, use_clus_name = &quot;spat_netw_clus&quot;, heatmap_legend_param = list(title = NULL), save_param = list(base_height = 6, base_width = 8, units = &quot;cm&quot;)) Rank spatial correlated clusters and show genes for selected clusters netw_ranks = rankSpatialCorGroups(visium_brain, spatCorObject = spat_cor_netw_DT, use_clus_name = &quot;spat_netw_clus&quot;, save_param = list(base_height = 3, base_width = 5)) top_netw_spat_cluster = showSpatialCorFeats(spat_cor_netw_DT, use_clus_name = &quot;spat_netw_clus&quot;, selected_clusters = 6, show_top_feats = 1) Create metagene enrichment score for clusters cluster_genes_DT = showSpatialCorFeats(spat_cor_netw_DT, use_clus_name = &quot;spat_netw_clus&quot;, show_top_feats = 1) cluster_genes = cluster_genes_DT$clus names(cluster_genes) = cluster_genes_DT$feat_ID visium_brain &lt;- createMetafeats(visium_brain, feat_clusters = cluster_genes, name = &quot;cluster_metagene&quot;) spatCellPlot(visium_brain, spat_enr_names = &quot;cluster_metagene&quot;, cell_annotation_values = netw_ranks$clusters, point_size = 1, cow_n_col = 5, save_param = list(base_width = 15)) Spatially informed clusters Get the top 30 genes per spatial co-expression cluster table(spat_cor_netw_DT$cor_clusters$spat_netw_clus) coexpr_dt = data.table::data.table(genes = names(spat_cor_netw_DT$cor_clusters$spat_netw_clus), cluster = spat_cor_netw_DT$cor_clusters$spat_netw_clus) data.table::setorder(coexpr_dt, cluster) top30_coexpr_dt = coexpr_dt[, head(.SD, 30) , by = cluster] my_spatial_genes = top30_coexpr_dt$genes Re-calculate the clustering visium_brain &lt;- runPCA(gobject = visium_brain, feats_to_use = my_spatial_genes, name = &quot;custom_pca&quot;) visium_brain &lt;- runUMAP(visium_brain, dim_reduction_name = &quot;custom_pca&quot;, dimensions_to_use = 1:20, name = &quot;custom_umap&quot;) visium_brain &lt;- createNearestNetwork(gobject = visium_brain, dim_reduction_name = &quot;custom_pca&quot;, dimensions_to_use = 1:20, k = 5, name = &quot;custom_NN&quot;) visium_brain &lt;- doLeidenCluster(gobject = visium_brain, network_name = &quot;custom_NN&quot;, resolution = 0.15, n_iterations = 1000, name = &quot;custom_leiden&quot;) cell_meta = pDataDT(visium_brain) cell_clusters = unique(cell_meta$custom_leiden) selected_colors = getDistinctColors(length(cell_clusters)) names(selected_colors) = cell_clusters Visualize spatPlot2D(visium_brain, cell_color = &quot;custom_leiden&quot;, cell_color_code = selected_colors, coord_fix_ratio = 1) plotUMAP(gobject = visium_brain, cell_color = &quot;custom_leiden&quot;, cell_color_code = selected_colors, point_size = 1.5) Spatial domains HMRF Do HMRF with different betas on top 30 genes per spatial co-expression module hmrf_folder = paste0(results_folder,&quot;/&quot;,&quot;11_HMRF/&quot;) if(!file.exists(hmrf_folder)) dir.create(hmrf_folder, recursive = T) HMRF_spatial_genes = doHMRF(gobject = visium_brain, expression_values = &quot;scaled&quot;, spatial_genes = my_spatial_genes, k = 20, spatial_network_name=&quot;spatial_network&quot;, betas = c(0, 10, 5), output_folder = paste0(hmrf_folder, &quot;/&quot;, &quot;Spatial_genes/SG_topgenes_k20_scaled&quot;)) visium_brain &lt;- addHMRF(gobject = visium_brain, HMRFoutput = HMRF_spatial_genes, k = 20, betas_to_add = c(0, 10, 20, 30, 40), hmrf_name = &quot;HMRF&quot;) spatPlot2D(gobject = visium_brain, cell_color = &quot;HMRF_k20_b.40&quot;) 7.5 Interactive tools text "],["visium-hd.html", "8 Visium HD 8.1 Data Ingestion 8.2 Tiling and aggregation 8.3 Scalability and projection functions 8.4 Spatial expression patterns 8.5 Spatial co-expression modules", " 8 Visium HD Edward C. Ruiz August 6th 2024 8.1 Data Ingestion 8.1.1 Read in raw data # get10Xmatrix() 8.1.2 Use convenience function # createGiottoVisiumHDObject() 8.2 Tiling and aggregation text # tessellate() 8.3 Scalability and projection functions filter and normalization workflow PCA projection 8.4 Spatial expression patterns plotting 8.5 Spatial co-expression modules binspect? "],["xenium.html", "9 Xenium 9.1 Introduction to spatial dataset", " 9 Xenium Jiaji George Chen August 6th 2024 9.1 Introduction to spatial dataset This is the 10X Xenium FFPE Human Lung Cancer dataset. Xenium captures individual transcript detections with a spatial resolution of 100s of nanometers, providing an extremely highly resolved subcellular spatial dataset. This particular dataset also showcases their newly released multimodal cell segmentation outputs. Previous Xenium datasets provided nuclear segmentations based on DAPI then generated cell The Xenium Human Multi-Tissue and Cancer Panel (377) genes was used. The exported data is from their Xenium Onboard Analysis v2.0.0 pipeline. The data to run this tutorial can be found here The files can be downloaded by running the following in the bash terminal: # Input Files wget https://cf.10xgenomics.com/samples/xenium/2.0.0/Xenium_V1_humanLung_Cancer_FFPE/Xenium_V1_humanLung_Cancer_FFPE_gene_panel.json wget https://cf.10xgenomics.com/samples/xenium/2.0.0/Xenium_V1_humanLung_Cancer_FFPE/Xenium_V1_humanLung_Cancer_FFPE_he_image.ome.tif wget https://cf.10xgenomics.com/samples/xenium/2.0.0/Xenium_V1_humanLung_Cancer_FFPE/Xenium_V1_humanLung_Cancer_FFPE_he_imagealignment.csv # Output Files wget https://cf.10xgenomics.com/samples/xenium/2.0.0/Xenium_V1_humanLung_Cancer_FFPE/Xenium_V1_humanLung_Cancer_FFPE_outs.zip wget https://cf.10xgenomics.com/samples/xenium/2.0.0/Xenium_V1_humanLung_Cancer_FFPE/Xenium_V1_humanLung_Cancer_FFPE_xe_outs.zip Input Files are additional files that are not part of the output bundles, usually some raw files the pipeline uses or extra info. Output Files are the directories that are exported by the Xenium pipeline that can be expected from every run. "],["additional-install-requirements.html", "10 Additional install requirements 10.1 Read in raw data 10.2 Overlap txs &amp; polygons 10.3 Transcript enrichment GSEA 10.4 Spatial location analysis 10.5 Visualizations", " 10 Additional install requirements arrow is needed requires ZTSD codec to open these parquets. save_dir &lt;- &quot;~/Documents/GitHub/giotto_workshop_2024/img/02_session3&quot; 10.1 Read in raw data Transcript coordinates Polygon coordinates Visualizations affine mapping? 10.2 Overlap txs &amp; polygons Typical aggregated workflow Feature/molecule specific analysis Visualizations 10.3 Transcript enrichment GSEA text 10.4 Spatial location analysis Spatial cell type co-localization analysis Spatial niche analysis Spatial niche trajectory analysis 10.5 Visualizations zarr_exp &lt;- “https://scc-ondemand1.bu.edu/pun/sys/dashboard/files/fs//projectnb/rd-spat/DATA/Public_data/Spatial/Multiplexing_RNA/xenium/v2.0_pipeline/FFPE_LungCancer/cell_features” datadir &lt;- “/projectnb2/rd-spat/DATA/Public_data/Spatial/Multiplexing_RNA/xenium/v2.0_pipeline/FFPE_LungCancer/” manifest &lt;- list.files( datadir, full.names = TRUE, ) |&gt; as.list() names(manifest) &lt;- list.files(datadir) force(names(manifest)) tx_path &lt;- manifest\\(transcripts.csv.gz poly_cell_path &lt;- manifest\\)cell_boundaries.csv.gz poly_nuc_path &lt;- manifest$nucleus_boundaries.csv.gz image_path &lt;- manifest\\(Xenium_V1_humanLung_Cancer_FFPE_he_image.ome.tif aff_path &lt;- manifest\\)Xenium_V1_humanLung_Cancer_FFPE_he_imagealignment.csv cell &lt;- manifest$cells.csv.gz "],["exploration.html", "11 —– exploration", " 11 —– exploration "],["image.html", "12 IMAGE", " 12 IMAGE aff &lt;- data.table::fread(aff_path) reticulate::source_python(file = “/projectnb/rd-spat/HOME/george/scripts/tifffile_convert.py”) GiottoUtils::package_check(“os”, repository = “pip:os”) GiottoUtils::package_check(“multiprocessing”, repository = “pip:multiprocessing”) GiottoUtils::package_check(“tifffile”, repository = “pip:tifffile”) out_tif &lt;- “/projectnb/rd-spat/HOME/george/tmp/tifffile_testing/test.tif” "],["ometif_2_tifimage_path-output_file-out_tif-chunk_rows-chunk_rows-overwrite-true.html", "13 ometif_2_tif(image_path, output_file = out_tif, chunk_rows = chunk_rows, overwrite = TRUE)", " 13 ometif_2_tif(image_path, output_file = out_tif, chunk_rows = chunk_rows, overwrite = TRUE) ometif_2_tif(image_path, output_file = out_tif, overwrite = TRUE) test &lt;- createGiottoLargeImage(out_tif) n_before &lt;- .nr(tx_arrow) tx_arrow &lt;- dplyr::filter(tx_arrow, qv &gt; qv_threshold) n_after &lt;- .nr(tx_arrow) out_if_fmt &lt;- “/projectnb/rd-spat/HOME/george/tmp/tifffile_testing/if%d.tif” source_if_fmt &lt;- “/projectnb2/rd-spat/DATA/Public_data/Spatial/Multiplexing_RNA/xenium/v2.0_pipeline/FFPE_LungCancer//morphology_focus/morphology_focus_000%d.ome.tif” ometif_2_tif(sprintf(source_if_fmt, 0), output_file = sprintf(out_if_fmt, 0), overwrite = TRUE) ometif_2_tif(sprintf(source_if_fmt, 1), output_file = sprintf(out_if_fmt, 1), overwrite = TRUE) ometif_2_tif(sprintf(source_if_fmt, 2), output_file = sprintf(out_if_fmt, 2), overwrite = TRUE) ometif_2_tif(sprintf(source_if_fmt, 3), output_file = sprintf(out_if_fmt, 3), overwrite = TRUE) img_if_list &lt;- lapply( sprintf(out_if_fmt, 0:3), createGiottoLargeImage ) "],["example-usage.html", "14 # Example usage", " 14 # Example usage "],["input_file-pathtoinputfile.ome.html", "15 input_file = “path/to/input/file.ome.tif”", " 15 input_file = “path/to/input/file.ome.tif” "],["output_file-pathtooutputfile.html", "16 output_file = “path/to/output/file.tif”", " 16 output_file = “path/to/output/file.tif” "],["chunk_size-1000-1000-adjust-the-chunk-size-as-needed.html", "17 chunk_size = (1000, 1000) # Adjust the chunk size as needed", " 17 chunk_size = (1000, 1000) # Adjust the chunk size as needed "],["num_processes-4-adjust-the-number-of-processes-based-on-available-cpu-cores.html", "18 num_processes = 4 # Adjust the number of processes based on available CPU cores", " 18 num_processes = 4 # Adjust the number of processes based on available CPU cores "],["section.html", "19 ", " 19 "],["ometif_2_tifinput_file-output_file-chunk_size-num_processes.html", "20 ometif_2_tif(input_file, output_file, chunk_size, num_processes)", " 20 ometif_2_tif(input_file, output_file, chunk_size, num_processes) "],["transcripts.html", "21 TRANSCRIPTS", " 21 TRANSCRIPTS tx &lt;- data.table::fread(tx_path, colClasses = c(transcript_id = “character”)) poly_cell_dt &lt;- data.table::fread(poly_cell_path) poly_nuc_dt &lt;- data.table::fread(poly_nuc_path) gpoints_list &lt;- GiottoClass::createGiottoPoints( tx, x_colname = “x_location”, y_colname = “y_location”, feat_ID_colname = “feature_name”, feat_type = c(“rna”, “NegControlProbe”, “UnassignedCodeword”, “NegControlCodeword”), split_keyword = list(“NegControlProbe”, “UnassignedCodeword”, “NegControlCodeword”) ) gp_filter &lt;- gpoints_list\\(rna[gpoints_list\\)rna$qv &gt;= 20] "],["where-are-the-issue-tx-at.html", "22 where are the issue TX at?", " 22 where are the issue TX at? plot(gp_filter@spatVector, values = gp_filter$qv, type = “continuous”, cex = 0.1, col = GiottoVisuals::getColors(“magma”)) library(ggplot2) type_qv &lt;- data.table::rbindlist( list( data.table::data.table(type = “genes”, qv = gpoints_list\\(rna\\)qv), data.table::data.table(type = “NegControlProbe”, qv = gpoints_list\\(NegControlProbe\\)qv), data.table::data.table(type = “UnassignedCodeword”, qv = gpoints_list\\(UnassignedCodeword\\)qv), data.table::data.table(type = “NegControlCodeword”, qv = gpoints_list\\(NegControlCodeword\\)qv) ) ) ggplot(data = type_qv, aes(x = type, y = qv, fill = type)) + geom_violin() "],["polys.html", "23 POLYS", " 23 POLYS gpoly_cell &lt;- createGiottoPolygon(poly_cell_dt, name = “cell”) gpoly_nuc &lt;- createGiottoPolygon(poly_nuc_dt, name = “nucleus”) mini_ext &lt;- ext(6500,7500, 1300, 2000) plot(gpoly_cell, col = “magenta”, ext = mini_ext, background = “black”) plot(gpoly_nuc, add = T, col = “cyan”, ext = mini_ext) plot(gp_filter, add = T, col = “yellow”, alpha = 0.3, ext = mini_ext, raster = F) "],["giotto.html", "24 giotto", " 24 giotto g &lt;- giotto() g &lt;- setGiotto(g, gp_filter) g &lt;- setGiotto(g, gpoly_cell) g &lt;- setGiotto(g, gpoly_nuc) g &lt;- calculateOverlap( g, feat_info = “rna”, spatial_info = “cell”, return_gobject = T ) g &lt;- overlapToMatrix( g, poly_info = “cell”, feat_info = “rna”, return_gobject = TRUE ) savedir &lt;- “/projectnb2/rd-spat/HOME/george/projects/xenium_processing/lung_test/” instructions(g, “save_dir”) &lt;- savedir instructions(g, “save_plot”) &lt;- TRUE instructions(g, “return_plot”) &lt;- FALSE instructions(g, “show_plot”) &lt;- FALSE g &lt;- addStatistics(g, expression_values = “raw”) spatPlot2D(g, cell_color = “total_expr”, color_as_factor = FALSE, point_shape = “no_border”, point_size = 0.1, gradient_style = “s”, background_color = “black”, save_param = list( base_width = 15, base_height = 6 )) hist(pDataDT(g)$nr_feats) filterCombinations( g, feat_det_in_min_cells = c(100, 200, 200), min_det_feats_per_cell = c(10, 20, 30), expression_thresholds = 1 ) g &lt;- filterGiotto( g, feat_det_in_min_cells = 100, min_det_feats_per_cell = 10, expression_threshold = 1 ) g &lt;- normalizeGiotto(g) "],["no-hvf-calc-since-there-are-not-that-many-different-gene-species.html", "25 no HVF calc since there are not that many different gene species", " 25 no HVF calc since there are not that many different gene species g &lt;- runPCA(gobject = g, spat_unit = ‘cell’, expression_values = ‘scaled’, feats_to_use = NULL, scale_unit = F, center = F) screePlot(g, ncp = 20) my_colors &lt;- c(“#6D0C00”, “magenta”, “#FFBBCE”, “#FFDDDF”, “#FFEEEE”, “#FFFEFE”, “white”, “white”) plotPCA(g, cell_color = “total_expr”, color_as_factor = FALSE, cell_color_gradient = my_colors, point_shape = “no_border”, gradient_style = “s”, background = “black”, point_size = 0.1, save_param = list( save_name = “pca_expr” ) ) g &lt;- runUMAPprojection( g, dimensions_to_use = 1:15, random_subset = 10000 ) dimPlot2D( g, dim_reduction_name = “umap.projection”, dim_reduction_to_use = “umap”, cell_color = “total_expr”, cell_color_gradient = my_colors, color_as_factor = FALSE, point_shape = “no_border”, gradient_style = “s”, background = “black”, point_size = 0.1, save_param = list( save_name = “umap.projection_expr” ) ) g &lt;- createNearestNetwork(g) "],["set-seed-for-reproducibility.html", "26 set seed for reproducibility", " 26 set seed for reproducibility set.seed(123) g_mini &lt;- subsetGiotto(g, cell_ids = sample(spatIDs(g), size = 10000)) g_mini &lt;- createNearestNetwork(g_mini) g_mini &lt;- doLeidenCluster(g_mini, resolution = 1.4) "],["dimplot2d.html", "27 dimPlot2D(", " 27 dimPlot2D( "],["g_mini.html", "28 g_mini,", " 28 g_mini, "],["spat_unit-cell.html", "29 spat_unit = “cell”,", " 29 spat_unit = “cell”, "],["feat_type-rna.html", "30 feat_type = “rna”,", " 30 feat_type = “rna”, "],["cell_color-leiden_clus.html", "31 cell_color = “leiden_clus”,", " 31 cell_color = “leiden_clus”, "],["dim_reduction_name-umap.html", "32 dim_reduction_name = “umap.projection”,", " 32 dim_reduction_name = “umap.projection”, "],["dim_reduction_to_use-umap.html", "33 dim_reduction_to_use = “umap”,", " 33 dim_reduction_to_use = “umap”, "],["save_param-list.html", "34 save_param = list(", " 34 save_param = list( "],["save_name-mini_umap_1.html", "35 save_name = “mini_umap_1.2”", " 35 save_name = “mini_umap_1.2” "],["section-1.html", "36 )", " 36 ) "],["section-2.html", "37 )", " 37 ) clus_color &lt;- getColors(“Vivid”, n = 17)[] clus_color[9] &lt;- “lightgrey” clus_color[5] &lt;- “yellow” clus_color[3] &lt;- “#00AAFF” clus_color[6] &lt;- “darkgreen” clus_color &lt;- clus_color[c(2, 5, 1, 7, 6, 3, 4, 9, 8, 10, 12, 11, 14, 13, 15, 16, 17)] clus_color &lt;- c(“#00AAFF”, “#E58606”, “#B763A7”, “#437478”, “#87727B”, “darkgreen”, “#56BC9D”, “#5668AF”, “yellow”, “#B99F3A”, “#E5625E”, “#448DAE”, “#A5AA99”, “#D8497A”, “#93538D”, “#BF5C91”, “lightgrey”) dimPlot2D( g_mini, spat_unit = “cell”, feat_type = “rna”, cell_color = “leiden_clus”, cell_color_code = clus_color, dim_reduction_name = “umap.projection”, dim_reduction_to_use = “umap”, save_param = list( save_name = “mini_umap_1.4” ) ) "],["seems-like-a-good-res.html", "38 1.4 seems like a good res", " 38 1.4 seems like a good res "],["project-values-back-via-knn-classifier-fnnknn.html", "39 project values back via kNN classifier (FNN::knn)", " 39 project values back via kNN classifier (FNN::knn) g &lt;- doClusterProjection( target_gobject = g, target_cluster_label_name = “leiden_clus”, source_gobject = g_mini, # res 1.4 source_cluster_labels = “leiden_clus” ) dimPlot2D(g, cell_color = “leiden_clus”, cell_color_code = clus_color[c(1, 10:17, 2:9)], dim_reduction_to_use = “umap”, dim_reduction_name = “umap.projection”, save_param = list( save_name = “umap.project_1.4” )) cellmeta &lt;- pDataDT(g) cellmeta[, major_clus := leiden_clus] cellmeta[major_clus %in% c(1, 7, 6, 8, 3, 5), major_clus := “combined_1”] m_clus &lt;- cellmeta[, c(“cell_ID”, “major_clus”)] g &lt;- addCellMetadata(g, new_metadata = m_clus, by_column = T) spatPlot2D(g, cell_color = “leiden_clus”, point_size = 0.1, point_shape = “no_border”, cell_color_code = clus_color[c(1, 10:17, 2:9)], background = “black”, save_param = list( base_width = 15, base_height = 6, save_name = “spat_leiden” )) "],["spatplot2dg-cell_color-major_clus.html", "40 spatPlot2D(g, cell_color = “major_clus”,", " 40 spatPlot2D(g, cell_color = “major_clus”, "],["point_size-0.html", "41 point_size = 0.1,", " 41 point_size = 0.1, "],["point_shape-no_border.html", "42 point_shape = “no_border”,", " 42 point_shape = “no_border”, "],["cell_color_code-clus_colorc1-1017-29c1359-14-17-11.html", "43 cell_color_code = clus_color[c(1, 10:17, 2:9)][c(1:3,5:9, 14, 17, 11)],", " 43 cell_color_code = clus_color[c(1, 10:17, 2:9)][c(1:3,5:9, 14, 17, 11)], "],["background-black.html", "44 background = “black”,", " 44 background = “black”, "],["save_param-list-1.html", "45 save_param = list(", " 45 save_param = list( "],["base_width-15.html", "46 base_width = 15,", " 46 base_width = 15, "],["base_height-6.html", "47 base_height = 6,", " 47 base_height = 6, "],["save_name-spat_major.html", "48 save_name = “spat_major”", " 48 save_name = “spat_major” "],["section-3.html", "49 ))", " 49 )) spatFeatPlot2D(g, feats = c(“MKI67”, “CD3E”, “CD4”, “CD8A”, “CD19”, “CD79A”), point_size = 0.1, point_shape = “no_border”, background = “black”, cow_n_col = 1L, gradient_style = “s”, save_param = list( base_width = 15, base_height = 30 )) spatFeatPlot2D(g, feats = c(“CD68”, “CD27”, “SFTA2”, “KRT7”, “SERPINB3”, “SOX2”, “SMOC”), point_size = 0.1, point_shape = “no_border”, background = “black”, cow_n_col = 1L, gradient_style = “s”, save_param = list( base_width = 15, base_height = 30 )) "],["niches.html", "50 niches", " 50 niches g = createSpatialNetwork( gobject = g, spat_unit = ‘cell’, method = ‘Delaunay’ ) g = calculateSpatCellMetadataProportions( gobject = g, spat_unit = ‘cell’, feat_type = ‘rna’, spat_network = ‘Delaunay_network’, metadata_column = ‘leiden_clus’, name = ‘proportion’ ) "],["visualize-niche-level-enrichment-for-leiden-cluster-3-in-spat_unit-cell.html", "51 visualize niche-level enrichment for leiden cluster 3 in spat_unit “cell”", " 51 visualize niche-level enrichment for leiden cluster 3 in spat_unit “cell” spatPlot2D( gobject = g, spat_unit = ‘cell’, point_size = 0.1, spat_enr_names = ‘proportion’, color_as_factor = FALSE, gradient_style = ‘sequential’, cell_color = ‘3’, point_shape = “no_border”, save_param = list( save_name = “niche_3”, base_width = 15, base_height = 6 ) ) prop_table = getSpatialEnrichment( g, spat_unit = ‘cell’, name = ‘proportion’, output = ‘data.table’ ) # convert the data.table to a sparse Matrix with row and colnames # here we use a utility function to perform the operation prop_matrix = GiottoUtils::dt_to_matrix(prop_table) "],["these-enrichments-are-essentially-a-measure-of-how-many-cells-of-each.html", "52 These enrichments are essentially a measure of how many cells of each", " 52 These enrichments are essentially a measure of how many cells of each "],["leiden-cluster-exist-in-the-local-region.html", "53 leiden cluster exist in the local region", " 53 leiden cluster exist in the local region "],["section-4.html", "54 ", " 54 "],["using-kmeans-we-can-classify-each-cell-by-its-niche-leiden-cluster-proportions.html", "55 Using kmeans, we can classify each cell by its niche leiden cluster proportions", " 55 Using kmeans, we can classify each cell by its niche leiden cluster proportions set.seed(12345) # set seed for kmeans prop_kmeans = kmeans(x = prop_matrix, centers = 6, iter.max = 100, nstart = 3) prop_kmeansDT = data.table::data.table( cell_ID = names(prop_kmeans\\(cluster), niche = prop_kmeans\\)cluster ) "],["add-kmeans-clustering-of-niches-to-cell-metadata.html", "56 add kmeans clustering of niches to cell metadata", " 56 add kmeans clustering of niches to cell metadata g = addCellMetadata( g, spat_unit = ‘cell’ , new_metadata = prop_kmeansDT, by_column = TRUE, column_cell_ID = ‘cell_ID’ ) "],["spatially-visualize-the-niches.html", "57 Spatially visualize the niches", " 57 Spatially visualize the niches spatPlot(gobject = g, show_network = TRUE, network_color = ‘lightgray’, spatial_network_name = ‘Delaunay_network’, cell_color = ‘niche’, point_size = 0.1, point_shape = “no_border”, save_param = list( save_name = “niches”, base_width = 15, base_height = 6 )) "],["gene-enrichment.html", "58 Gene enrichment", " 58 Gene enrichment scran_markers &lt;- findScranMarkers_one_vs_all( g, cluster_column = “leiden_clus”, expression_values = “normalized” ) topgenes_scran = scran_markers[, head(.SD, 2), by = ‘cluster’]$feats "],["violinplot.html", "59 violinplot", " 59 violinplot violinPlot(g, feats = unique(topgenes_scran), cluster_column = ‘leiden_clus’, strip_text = 10, strip_position = ‘right’, save_param = list(base_width = 5)) "],["spatial-proteomics-multiplex-if.html", "60 Spatial proteomics: multiplex IF 60.1 Read in raw data 60.2 Overlap intensity &amp; workflows", " 60 Spatial proteomics: multiplex IF Junxiang Xu August 6th 2024 60.1 Read in raw data Intensity data (IF or any other image) Polygon coordinates Visualizations 60.2 Overlap intensity &amp; workflows Typical aggregated workflow Visualizations "],["working-with-multiple-samples.html", "61 Working with multiple samples 61.1 Create individual giotto objects 61.2 Join Giotto Objects 61.3 Perform Harmony and default workflows 61.4 Visualizations", " 61 Working with multiple samples Jeff Sheridan August 7th 2024 61.1 Create individual giotto objects 61.2 Join Giotto Objects 61.3 Perform Harmony and default workflows 61.4 Visualizations "],["spatial-multi-modal-analysis.html", "62 Spatial multi-modal analysis 62.1 Co-registration of datasets 62.2 Examples in giotto suite manuscript", " 62 Spatial multi-modal analysis Junxiang Xu August 7th 2024 62.1 Co-registration of datasets text 62.2 Examples in giotto suite manuscript text "],["multi-omics-integration.html", "63 Multi-omics integration 63.1 Example in giotto suite manuscript", " 63 Multi-omics integration Joselyn Cristina Chávez Fuentes August 7th 2024 63.1 Example in giotto suite manuscript text "],["interoperability-with-other-frameworks.html", "64 Interoperability with other frameworks 64.1 AnnData/SpatialData 64.2 SpatialExperiment 64.3 Seurat", " 64 Interoperability with other frameworks Iqra August 7th 2024 64.1 AnnData/SpatialData text 64.2 SpatialExperiment text 64.3 Seurat text "],["interoperability-with-isolated-tools.html", "65 Interoperability with isolated tools 65.1 Spatial niche trajectory analysis", " 65 Interoperability with isolated tools Wen Wang August 7th 2024 65.1 Spatial niche trajectory analysis text "],["interactivity-with-the-rspatial-ecosystem.html", "66 Interactivity with the R/Spatial ecosystem 66.1 Kriging", " 66 Interactivity with the R/Spatial ecosystem Jeff Sheridan August 7th 2024 66.1 Kriging text "],["contributing-to-giotto.html", "67 Contributing to Giotto 67.1 Contribution guideline", " 67 Contributing to Giotto Jiaji George Chen August 7th 2024 save_dir &lt;- &quot;~/Documents/GitHub/giotto_workshop_2024/img/03_session7&quot; 67.1 Contribution guideline https://drieslab.github.io/Giotto_website/CONTRIBUTING.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
