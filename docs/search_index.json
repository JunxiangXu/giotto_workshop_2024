[["visium-hd.html", "9 Visium HD 9.1 Objective 9.2 Background 9.3 Data Ingestion 9.4 Create Giotto object 9.5 Process Giotto object 9.6 Dimension reduction + clustering 9.7 Hexbin 100 9.8 Hexbin 25", " 9 Visium HD Ruben Dries &amp; Edward C. Ruiz August 6th 2024 9.1 Objective This tutorial demonstrates how to process Visium HD data at the highest 2 micron bin resolution using Giotto Suite. Notably, a similar strategy can be used for other spatial sequencing methods that operate at the subcellular level, including: - Stereo-seq - Seq-Scope - Open-ST The resulting datasets from all these technologies can be very large since they provide both a high spatial resolution and genome-wide capture of all transcripts. 9.2 Background 9.2.1 Visium HD Technology Figure 9.1: Overview of Visium HD. Source: 10X Genomics Visium HD is a spatial transcriptomics technology recently developed by 10X Genomics. Details about this platform are discussed on the official 10X Genomics Visium HD website and the preprint by Oliveira et al. 2024 on bioRxiv. Visium HD has a 2 micron bin size resolution. The default SpaceRanger pipeline from 10X Genomics also returns aggregated data at the 8 and 16 micron bin size. 9.2.2 Colorectal Cancer Sample Figure 9.2: Colorectal Cancer Overview. Source: 10X Genomics For this tutorial we will be using the publicly available Colorectal Cancer Visium HD dataset. Details about this dataset and a link to download the raw data can be found at the 10X Genomics website. 9.3 Data Ingestion 9.3.1 Visium HD output data format Figure 9.3: File structure of Visium HD data processed with spaceranger pipeline. Visium HD data processed with the spaceranger pipeline is organized in this format containing various files associated with the sample. The files highlighted in yellow are what we will be using to read in these datasets. 9.3.2 Mini Visium HD dataset library(Giotto) # set up paths data_path &lt;- &quot;data/02_session2/&quot; save_dir &lt;- &quot;results/02_session2/&quot; dir.create(save_dir, recursive = TRUE) # download the mini dataset and untar options(&quot;timeout&quot; = Inf) download.file( url = &quot;https://zenodo.org/records/13212855/files/workshop_VisiumHD.zip?download=1&quot;, destfile = file.path(save_dir, &quot;workshop_visiumHD.zip&quot;) ) untar(tarfile = file.path(save_dir, &quot;workshop_visiumHD.zip&quot;), exdir = data_path) 9.3.3 Giotto Visium HD convenience function The easiest way to read in Visium HD data in Giotto is through our convenience function. This function will automatically read in the data at your desired resolution, align the images, and finally create a Giotto Object. # importVisiumHD() However, for this tutorial we will illustrate how to create your own Giotto object in a step-by-step manner, which can also be applied to other similar technologies as discussed in the Objective section. 9.3.4 Read in data manually 9.3.4.1 Raw expression data expression_path = file.path(data_path, &#39;raw_feature_bc_matrix&#39;) expr_results &lt;- get10Xmatrix(path_to_data = expression_path, gene_column_index = 1) 9.3.4.2 Tissue positions data tissue_positions_path = file.path(data_path, &#39;spatial&#39;, &#39;tissue_positions.parquet&#39;) tissue_positions = data.table::as.data.table(arrow::read_parquet(tissue_positions_path)) 9.3.4.3 Merge expression and 2 micron position data # convert expression matrix to minimal data.frame or data.table object matrix_tile_dt = data.table::as.data.table(Matrix::summary(expr_results)) genes = expr_results@Dimnames[[1]] samples = expr_results@Dimnames[[2]] matrix_tile_dt[, gene := genes[i]] matrix_tile_dt[, pixel := samples[j]] # merge data.table matrix and spatial coordinates to create input for Giotto Polygons expr_pos_data = data.table::merge.data.table(matrix_tile_dt, tissue_positions, by.x = &#39;pixel&#39;, by.y = &#39;barcode&#39;) expr_pos_data = expr_pos_data[,.(pixel, pxl_row_in_fullres, pxl_col_in_fullres, gene, x)] colnames(expr_pos_data) = c(&#39;pixel&#39;, &#39;x&#39;, &#39;y&#39;, &#39;gene&#39;, &#39;counts&#39;) 9.4 Create Giotto object 9.4.1 create giotto points giotto_points = createGiottoPoints(x = expr_pos_data[,.(x, y, gene, pixel, counts)]) 9.4.2 create giotto polygons 9.4.2.1 Tiling and aggregation The Visium HD data is organized in a grid format. We can aggregate the data into larger bins to reduce the dimensionality of the data. Giotto Suite provides options to bin data not only with squares, but also through hexagons and triangles. Here we use a hexagon tesselation to aggregate the data into arbitrary cells. # create giotto polygons, here we create hexagons hexbin400 &lt;- tessellate(extent = ext(giotto_points), shape = &#39;hexagon&#39;, shape_size = 400, name = &#39;hex400&#39;) plot(hexbin400) 9.4.3 combine Giotto points and polygons to create Giotto object instrs = createGiottoInstructions( save_dir = results_folder, save_plot = TRUE, show_plot = FALSE, return_plot = FALSE ) visiumHD = createGiottoObjectSubcellular(gpoints = list(&#39;rna&#39; = giotto_points), gpolygons = list(&#39;hex400&#39; = hexbin400), instructions = instrs) visiumHD = addSpatialCentroidLocations(gobject = visiumHD, poly_info = &#39;hex400&#39;) feature_data = fDataDT(visiumHD) spatInSituPlotPoints(visiumHD, show_image = F, feats = list(&#39;rna&#39; = feature_data$feat_ID[10:20]), show_legend = T, spat_unit = &#39;hex400&#39;, point_size = 0.25, show_polygon = TRUE, use_overlap = FALSE, polygon_feat_type = &#39;hex400&#39;, polygon_bg_color = NA, polygon_color = &#39;white&#39;, polygon_line_size = 0.1, expand_counts = TRUE, count_info_column = &#39;count&#39;, jitter = c(25,25)) spatInSituPlotPoints(visiumHD, show_image = F, feats = list(&#39;rna&#39; = feature_data$feat_ID[10:20]), show_legend = T, spat_unit = &#39;hex400&#39;, point_size = 0.25, show_polygon = TRUE, use_overlap = FALSE, polygon_feat_type = &#39;hex400&#39;, polygon_bg_color = NA, polygon_color = &#39;white&#39;, polygon_line_size = 0.1, expand_counts = TRUE, count_info_column = &#39;count&#39;, jitter = c(25,25), plot_method = &#39;scattermore&#39;) 9.5 Process Giotto object 9.5.1 calculate overlap between points and polygons # calculate overlap between points and polygons visiumHD = calculateOverlap(visiumHD, spatial_info = &#39;hex400&#39;, feat_info = &#39;rna&#39;) showGiottoSpatialInfo(visiumHD) 9.5.2 convert overlap results to a bin-by-gene matrix # convert overlap results to bin by gene matrix visiumHD = overlapToMatrix(visiumHD, poly_info = &#39;hex400&#39;, feat_info = &#39;rna&#39;, name = &#39;raw&#39;) activeSpatUnit(visiumHD) 9.5.3 default processing steps visiumHD &lt;- filterGiotto(visiumHD, expression_threshold = 1, feat_det_in_min_cells = 5, min_det_feats_per_cell = 25) # normalize visiumHD &lt;- normalizeGiotto(visiumHD, scalefactor = 1000, verbose = T) # add statistics visiumHD &lt;- addStatistics(visiumHD) 9.5.4 visualize number of features At the centroid level. # each dot here represents a 200x200 aggregation of spatial barcodes (bin size 200) spatPlot2D(gobject = visiumHD, cell_color = &quot;nr_feats&quot;, color_as_factor = F, point_size = 2.5) Using the spatial polygon (hexagon) tiles spatInSituPlotPoints(visiumHD, show_image = F, feats = NULL, show_legend = F, spat_unit = &#39;hex400&#39;, point_size = 0.1, show_polygon = TRUE, use_overlap = TRUE, polygon_feat_type = &#39;hex400&#39;, polygon_fill = &#39;nr_feats&#39;, polygon_fill_as_factor = F, polygon_bg_color = NA, polygon_color = &#39;white&#39;, polygon_line_size = 0.1) 9.6 Dimension reduction + clustering 9.6.1 Highly variable features + PCA visiumHD &lt;- calculateHVF(visiumHD, zscore_threshold = 1) visiumHD &lt;- runPCA(visiumHD, expression_values = &#39;normalized&#39;, feats_to_use = &#39;hvf&#39;) screePlot(visiumHD, ncp = 30) plotPCA(visiumHD) 9.6.2 UMAP reduction for visualization visiumHD &lt;- runUMAP(visiumHD, dimensions_to_use = 1:14, n_threads = 10) plotUMAP(gobject = visiumHD, point_size = 1) 9.6.3 Create network based on expression similarity + graph partition cluster # sNN network (default) visiumHD &lt;- createNearestNetwork(visiumHD, dimensions_to_use = 1:14, k = 5) ## leiden clustering #### visiumHD &lt;- doLeidenClusterIgraph(visiumHD, resolution = 0.5, n_iterations = 1000, spat_unit = &#39;hex400&#39;) plotUMAP(gobject = visiumHD, cell_color = &#39;leiden_clus&#39;, point_size = 1.5, show_NN_network = F, edge_alpha = 0.05) spatInSituPlotPoints(visiumHD, show_image = F, feats = NULL, show_legend = F, spat_unit = &#39;hex400&#39;, point_size = 0.25, show_polygon = TRUE, use_overlap = FALSE, polygon_feat_type = &#39;hex400&#39;, polygon_fill_as_factor = TRUE, polygon_fill = &#39;leiden_clus&#39;, polygon_color = &#39;black&#39;, polygon_line_size = 0.3) 9.7 Hexbin 100 Goal is to create a higher resolution bin (hex100) and add to the Giotto object. 9.7.1 Standard subcellular pipeline hexbin100 &lt;- tessellate(extent = ext(visiumHD), shape = &#39;hexagon&#39;, shape_size = 100, name = &#39;hex100&#39;) plot(hexbin100) visiumHD = setPolygonInfo(gobject = visiumHD, x = hexbin100, name = &#39;hex100&#39;, initialize = T) visiumHD = addSpatialCentroidLocations(gobject = visiumHD, poly_info = &#39;hex100&#39;) Set active spatial unit. This can also be set manually. activeSpatUnit(visiumHD) &lt;- &#39;hex100&#39; spatInSituPlotPoints(visiumHD, show_image = F, feats = list(&#39;rna&#39; = feature_data$feat_ID[1:20]), show_legend = T, spat_unit = &#39;hex100&#39;, point_size = 0.1, show_polygon = TRUE, use_overlap = FALSE, polygon_feat_type = &#39;hex100&#39;, polygon_bg_color = NA, polygon_color = &#39;white&#39;, polygon_line_size = 0.2, expand_counts = TRUE, count_info_column = &#39;count&#39;, jitter = c(25,25)) visiumHD = calculateOverlap(visiumHD, spatial_info = &#39;hex100&#39;, feat_info = &#39;rna&#39;) visiumHD = overlapToMatrix(visiumHD, poly_info = &#39;hex100&#39;, feat_info = &#39;rna&#39;, name = &#39;raw&#39;) visiumHD &lt;- filterGiotto(visiumHD, expression_threshold = 1, feat_det_in_min_cells = 10, min_det_feats_per_cell = 10) visiumHD &lt;- normalizeGiotto(visiumHD, scalefactor = 1000, verbose = T) visiumHD &lt;- addStatistics(visiumHD) pDataDT(visiumHD, spat_unit = &#39;hex100&#39;) pDataDT(visiumHD, spat_unit = &#39;hex400&#39;) ## dimension reduction #### # --------------------------- # visiumHD &lt;- calculateHVF(visiumHD, zscore_threshold = 1) visiumHD &lt;- runPCA(visiumHD, expression_values = &#39;normalized&#39;, feats_to_use = &#39;hvf&#39;) plotPCA(visiumHD) visiumHD &lt;- runUMAP(visiumHD, dimensions_to_use = 1:14, n_threads = 10) # plot UMAP, coloring cells/points based on nr_feats plotUMAP(gobject = visiumHD, point_size = 2) # sNN network (default) visiumHD &lt;- createNearestNetwork(visiumHD, dimensions_to_use = 1:14, k = 5) ## leiden clustering #### visiumHD &lt;- doLeidenClusterIgraph(visiumHD, resolution = 0.2, n_iterations = 1000) plotUMAP(gobject = visiumHD, cell_color = &#39;leiden_clus&#39;, point_size = 1.5, show_NN_network = F, edge_alpha = 0.05) spatInSituPlotPoints(visiumHD, show_image = F, feats = NULL, show_legend = F, spat_unit = &#39;hex100&#39;, point_size = 0.5, show_polygon = TRUE, use_overlap = FALSE, polygon_feat_type = &#39;hex100&#39;, polygon_fill_as_factor = TRUE, polygon_fill = &#39;leiden_clus&#39;, polygon_color = &#39;black&#39;, polygon_line_size = 0.3) 9.7.2 Spatial expression patterns 9.7.2.1 Identify single genes featData = fDataDT(visiumHD) hvf_genes = featData[hvf == &#39;yes&#39;]$feat_ID visiumHD = createSpatialNetwork(visiumHD, name = &#39;kNN_network&#39;, spat_unit = &#39;hex100&#39;, method = &#39;kNN&#39;, k = 8) ranktest = binSpect(visiumHD, spat_unit = &#39;hex100&#39;, subset_feats = hvf_genes, bin_method = &#39;rank&#39;, calc_hub = FALSE, do_fisher_test = TRUE, spatial_network_name = &#39;kNN_network&#39;) Visualize top 2 ranked spatial genes per expression bin: set1 = ranktest[high_expr &gt; 50 &amp; high_expr &lt; 100][1:2]$feats set2 = ranktest[high_expr &gt; 100 &amp; high_expr &lt; 200][1:2]$feats set3 = ranktest[high_expr &gt; 200 &amp; high_expr &lt; 400][1:2]$feats set4 = ranktest[high_expr &gt; 400 &amp; high_expr &lt; 1000][1:2]$feats set5 = ranktest[high_expr &gt; 1000][1:2]$feats # set 1 and 2 spatFeatPlot2D(visiumHD, expression_values = &#39;scaled&#39;, feats = c(set1, set2), cow_n_col = 2, point_size = 1) # set 3 to 5 spatFeatPlot2D(visiumHD, expression_values = &#39;scaled&#39;, feats = c(set3, set4, set5), cow_n_col = 2, point_size = 1) 9.7.2.2 Spatial co-expression modules ext_spatial_genes = ranktest[adj.p.value &lt; 0.05]$feats spat_cor_netw_DT = detectSpatialCorFeats(visiumHD, method = &#39;network&#39;, spatial_network_name = &#39;kNN_network&#39;, subset_feats = ext_spatial_genes) # cluster spatial genes spat_cor_netw_DT = clusterSpatialCorFeats(spat_cor_netw_DT, name = &#39;spat_netw_clus&#39;, k = 20) # visualize clusters heatmSpatialCorFeats(visiumHD, spatCorObject = spat_cor_netw_DT, use_clus_name = &#39;spat_netw_clus&#39;, heatmap_legend_param = list(title = NULL)) # create metagene enrichment score for clusters cluster_genes_DT = showSpatialCorFeats(spat_cor_netw_DT, use_clus_name = &#39;spat_netw_clus&#39;, show_top_feats = 1) cluster_genes = cluster_genes_DT$clus; names(cluster_genes) = cluster_genes_DT$feat_ID visiumHD = createMetafeats(visiumHD, expression_values = &#39;normalized&#39;, feat_clusters = cluster_genes, name = &#39;cluster_metagene&#39;) spatCellPlot(visiumHD, spat_enr_names = &#39;cluster_metagene&#39;, cell_annotation_values = as.character(c(1:4)), point_size = 1, cow_n_col = 2) spatCellPlot(visiumHD, spat_enr_names = &#39;cluster_metagene&#39;, cell_annotation_values = as.character(c(5:8)), point_size = 1, cow_n_col = 2) spatCellPlot(visiumHD, spat_enr_names = &#39;cluster_metagene&#39;, cell_annotation_values = as.character(c(9:10)), point_size = 1, cow_n_col = 2) balanced_genes = getBalancedSpatCoexpressionFeats(spatCorObject = spat_cor_netw_DT, maximum = 5) selected_feats = names(balanced_genes) # give genes from same cluster same color distinct_colors = getDistinctColors(n = 20) names(distinct_colors) = 1:20 my_colors = distinct_colors[balanced_genes] names(my_colors) = names(balanced_genes) spatInSituPlotPoints(visiumHD, show_image = F, feats = list(&#39;rna&#39; = selected_feats), feats_color_code = my_colors, show_legend = F, spat_unit = &#39;hex100&#39;, point_size = 0.20, show_polygon = TRUE, use_overlap = FALSE, polygon_feat_type = &#39;hex100&#39;, polygon_bg_color = NA, polygon_color = &#39;white&#39;, polygon_line_size = 0.05, jitter = c(25,25)) 9.8 Hexbin 25 9.8.1 Subcellular workflow and projection functions filter and normalization workflow PCA projection visiumHD_subset = subsetGiottoLocs(gobject = visiumHD, x_min = 16000, x_max = 20000, y_min = 44250, y_max = 45500) hexbin25 &lt;- tessellate(extent = ext(visiumHD_subset@feat_info$rna), shape = &#39;hexagon&#39;, shape_size = 25, name = &#39;hex25&#39;) visiumHD_subset = setPolygonInfo(gobject = visiumHD_subset, x = hexbin25, name = &#39;hex25&#39;, initialize = T) visiumHD_subset = addSpatialCentroidLocations(gobject = visiumHD_subset, poly_info = &#39;hex25&#39;) activeSpatUnit(visiumHD_subset) &lt;- &#39;hex25&#39; visiumHD_subset = calculateOverlap(visiumHD_subset, spatial_info = &#39;hex25&#39;, feat_info = &#39;rna&#39;) # convert overlap results to bin by gene matrix visiumHD_subset = overlapToMatrix(visiumHD_subset, poly_info = &#39;hex25&#39;, feat_info = &#39;rna&#39;, name = &#39;raw&#39;) visiumHD_subset &lt;- filterGiotto(visiumHD_subset, expression_threshold = 1, feat_det_in_min_cells = 25, min_det_feats_per_cell = 25) # normalize visiumHD_subset &lt;- normalizeGiotto(visiumHD_subset, scalefactor = 1000, verbose = T) # add statistics visiumHD_subset &lt;- addStatistics(visiumHD_subset) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
